'use strict';
/** @jsx h */

import CONST from './enums/CONST';
import PROPERTY_TYPES from './enums/PROPERTY_TYPES';
import Property from './do/Property';
import d3 from 'd3';

import { h, render, Component } from 'preact';

/* example component to start from */
class PropertiesManager extends Component {
  constructor(props) {
    super(props);

    this.state = {
      entity: props.entity || {},
      position: props.position || [],
      selectedProperty: null
    };
  }

  componentDidMount() {
    /** --------------------------
     * drag the property panel
     --------------------------- */

    let isDraggedByTheHandler = false;
    let startDragOffset = [0, 0];
    const $propertiesMenu = document.querySelector(`#${CONST.PROPERTY_MENU_ID}`);

    const drag = d3.behavior.drag()
        .on('dragstart', () => {
          const event = d3.event.sourceEvent;
          const target = event.target;
          isDraggedByTheHandler = target.classList.contains('drag-handler');
          startDragOffset = [target.offsetLeft + event.offsetX, target.offsetTop + event.offsetY];
        })
        .on('drag', () => {
          if (isDraggedByTheHandler) {
            this.setState({
              position: [`${d3.event.x - startDragOffset[0]}px`, `${d3.event.y - startDragOffset[1]}px`]
            });
          }
        });

    d3.select($propertiesMenu).call(drag);
  }

  selectProperty(prop) {
    this.setState({ selectedProperty: prop });
  }

  addProperty() {
    const entity = this.state.entity;
    entity.properties.push(new Property());

    this.setState({ entity });
  }

  changePropertyName(e, prop) {
    prop.key = e.target.value;
  }

  deleteProperty(prop) {
    const entity = this.state.entity;
    entity.properties = entity.properties.filter((property) => property.id !== prop.id);

    if (this.state.selectedProperty.id === prop.id) {
      this.setState({ selectedProperty: null });
    }

    this.setState({ entity });
  }

  render(props, state) {
    const entity = state.entity;
    const position = { left: state.position[0], top: state.position[1] };
    const typesWithLimit = [PROPERTY_TYPES.STRING, PROPERTY_TYPES.INT, PROPERTY_TYPES.FLOAT, PROPERTY_TYPES.URL, PROPERTY_TYPES.EMAIL, PROPERTY_TYPES.PASSWORD];
    const textTypes = [PROPERTY_TYPES.STRING, PROPERTY_TYPES.URL, PROPERTY_TYPES.EMAIL, PROPERTY_TYPES.PASSWORD];

    return <div id={CONST.PROPERTIES_MENU_LAYER_ID} className={CONST.PROPERTIES_MENU_LAYER_CLASS}>
      <div id={CONST.PROPERTY_MENU_ID} className={CONST.PROPERTY_MENU_CLASS} style={position}>
        <div className="header">
          <span className="color">
            <input id="entity-color" value={entity.color} type="color"
                   onChange={this.linkState('entity.color')}/>
          </span>
          <span className="label">
            <input id="entity-label" value={entity.label} onInput={ this.linkState('entity.label') }/>
            <small className="type">{entity.isNode && 'node' || entity.isEdge && 'edge'}</small>
            <span className="drag-handler"/>
          </span>
        </div>
        <div className="main">
          <div className="properties">
            <ul id="properties-list">
              { entity.properties.map((prop) => <li className={{ selected: (state.selectedProperty && prop.id === state.selectedProperty.id), disabled: prop.isSystem }}>
                <div className="property">
                  <input
                      type="text"
                      className="propertyName"
                      value={prop.key}
                      onInput={ (e) => this.changePropertyName(e, prop) }
                      onClick={this.selectProperty.bind(this, prop)}
                      disabled={prop.isSystem}
                  />
                  <small className="type">{prop.type}{prop.isRequired ? '!' : ''}{prop.isAutoGenerated ? '@' : ''}</small>
                  &nbsp;
                </div>
                <div className="remove-property-button" title="Delete" onClick={ this.deleteProperty.bind(this, prop) }>x</div>
              </li>)
              }
            </ul>
            <button className="add-button" onClick={ this.addProperty.bind(this) }>+ Add property</button>
          </div>
          { state.selectedProperty &&
          <div className="property-edit" id="property-edit">
            <ul>
              <li>
                <label>
                  <span>type:</span>
                  <select value={ state.selectedProperty.type } onChange={ this.linkState('selectedProperty.type') }>
                    {
                      Object.keys(PROPERTY_TYPES).map((type) => <option
                          value={PROPERTY_TYPES[type]}>{PROPERTY_TYPES[type]}</option>)
                    }
                  </select>
                </label>
              </li>
              { !state.selectedProperty.isAutoGenerated &&
              <li>
                <label>
                  <span>default value:</span>
                  <input
                      className="defaultValue"
                      value={ state.selectedProperty.defaultValue }
                      onInput={ this.linkState('selectedProperty.defaultValue') }
                  />
                </label>
              </li>
              }
              <li>
                <label>
                  <span>Required:</span>
                  <input
                      className="isRequired"
                      type="checkbox"
                      checked={ state.selectedProperty.isRequired }
                      onClick={ this.linkState('selectedProperty.isRequired') }
                  />
                </label>
              </li>
              <li>
                <label>
                  <span>Auto generated:</span>
                  <input
                      className="isRequired"
                      type="checkbox"
                      checked={ state.selectedProperty.isAutoGenerated }
                      onClick={ this.linkState('selectedProperty.isAutoGenerated') }
                  />
                </label>
              </li>

              { (typesWithLimit.indexOf(state.selectedProperty.type) !== -1) &&
              <li>
                <label>
                  <span>min{ textTypes.indexOf(state.selectedProperty.type) !== -1 ? ' length' : '' }:</span>
                  <input
                      className="limitMin"
                      type="number"
                      min="0"
                      max="100000"
                      value={state.selectedProperty.limitMin}
                      onInput={ this.linkState('selectedProperty.limitMin') }
                  />
                </label>
                <label>
                  <span>max{ textTypes.indexOf(state.selectedProperty.type) !== -1 ? ' length' : '' }:</span>
                  <input
                      className="limitMin"
                      type="number"
                      min="0"
                      max="100000"
                      value={state.selectedProperty.limitMax}
                      onInput={ this.linkState('selectedProperty.limitMax') }
                  />
                </label>
              </li>
              }
            </ul>
            <div className="propertyDescription">
              <label>
                <span>Description:</span>
                <input
                    value={state.selectedProperty.description}
                    onInput={ this.linkState('selectedProperty.description') }
                />
              </label>
            </div>
          </div>
          }
        </div>
        <div className="footer">
          <button id="save-button" onClick={ this.props.onClose.bind(this, this.state.entity) }>Close (Save Changes)</button>
        </div>
      </div>
    </div>;
  }
}

const PM = {
  /**
   * @param position
   * @param entity
   */
  open: (position, entity) => {
    const nodeToRender = document.querySelector(`#${CONST.PROPERTIES_MENU_LAYER_ID}`);
    const nodeToRenderTo = document.querySelector(`#${CONST.EDITOR_ID}`);

    //don't render if there is one in the dom
    if (!nodeToRender) {
      render(<PropertiesManager position={position} entity={entity} onClose={PM.close}/>, nodeToRenderTo);
    }
  },

  /**
   *
   */
  close: (entity) => {
    const pmLayer = document.querySelector(`#${CONST.PROPERTIES_MENU_LAYER_ID}`);

    if (pmLayer) {
      pmLayer.parentNode.removeChild(pmLayer);
      PM.close.closeHandler(entity);
    }
  },

  onClose: (closeHandler) => {
    PM.close.closeHandler = closeHandler;
  }
};

export default PM;
